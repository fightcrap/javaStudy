# java基础(一)-面向对象思想

### 前言
java是一门面向对象的语言，在学习java前，先要理解面向对象这个概念，区别于c这类的面向过程语言，面向对象有着什么一样的特点呢？先上一张思维导图吧：
![面向对象思维导图](https://raw.githubusercontent.com/fightcrap/javaStudy/master/image/java/base/46AC7A10-A89C-42E9-BEAA-2D13BDD02A91.png)

---
### 对象

#### 什么是对象
> 问题空间中的元素及其在解空间中的表示

这句话摘抄自*java编程思想*，是一句很难理解的话语（果然大佬的总结概括不是一般的抽象）。那么什么是问题空间？什么是在解空间呢？
1. 问题空间：问题空间是问题解决者对一个问题所达到的全部认识状态，它是由问题解决者利用问题所包含的信息和已贮存的信息主动地构成的。一般来说包括3部分：
   - 初始状态 -- 开始时的不完全的信息或令人不满意的状况，
   - 目标状态 -- 你希望获得的信息或状态或者说是目标状态
   - 操作  --为了从初始状态迈向目标状态，你可能采取的步骤

   如果拿方法来类比这段内容，初始状态也就是入参，目标状态是结果或者返回值，操作就是方法体啦。
2. 在解空间：emmmm这个没有找到具体的解释，不过有解空间的解释，应该类似：n元齐次线性方程组的解集S={x|Ax=0}是一个向量空间，称为齐次线性方程组的解空间。相当于问题的结果集。
大致概念解释完成了，貌似还是不好理解，用个人的话来讲：问题空间其实就是我们的问题，这个问题有什么条件，运算的过程，和问题解决后的状态。问题空间的元素都可以是一个对象。对象可以是一个有着独立特性的实体。解空间就是结果集了。问题的结果也是一个对象。**简单的说，对象其实就是一个可描述的实体，一个可描述的实体都可以是对象**

#### 对象的五个基本特性
- 万物皆对象（也就是所以可以描述的实体都可以是一个对象）
- 程序是对象的集合，它们通过发送消息的方式告知彼此要做的事情（发送消息其实就是方法的调用，或者通知）
- 每个对象都有着自己的以及其他对象所构成的存储（对象的构成可以是其他的对象组合，或者自己本身的一下特性组合而成）
- 每个对象都有着其类型：对象都有着自己的归属标示，比如它是属于那一类的对象，是人还是其他的可描述的类别。每一个对象都是其归属标示的一个实例
- 某一特定类型的所有对象都可以接收相同的信息（也就是它们对外开发的通信方式都是一致的）

以上就是对象的全部概念了，解释完了对象，那就要解释下对象的归属标示了，在java中这个称之为类

#### 什么是类
在上文有提到过每个对象都拥有其类型，这个类型在java中称之为类，类是具有相同特性（数据元素和行为）的对象集合
- 数据元素：我们一般当成特征，即该对象中有着那些属性来描述，比如长方形的长和宽。
- 行为：是方法的总称，如果我们把对象比作个体，那么方法就是个体可以做的事情，拥有的行为

---
上文解释了对象的概念，但是我们主要还是讲解一下面向对象，所有来解释下面向对象的内容吧。

### 面向对象

#### 什么是面向对象
面向对象思想可以看作一种在程序中包含各种独立而又互相调用的对象的思想。
与面向过程的做法不同，面向过程我们可以理解为流水线似操作，类似与我们现在机器化操作，对应特定过程，制定特定的方法。而面向对象就不同了，面向对象是基于对象，也就是说由对象的相互交流，协作来完成问题的解决，相当于我们的工人们做一些活，他们有着自己的技能，可以适用与不同的场景，交互配合实现。
![面向对象和面向过程区别](https://raw.githubusercontent.com/fightcrap/javaStudy/master/image/java/base/oop.jpg)
第一眼看貌似都是一样，无非就是面向对象多了一个维修工多概念，没错，维修工其实就是一个对象，面向对象把流程的实现都封装到了对象中，由对象的行为或者属性来处理问题。维修工是一个归类，不同的维修工是其具体表现。对于场景，流程是不会变的，更多是变化细节，在面向过程中，没错改动就是修改流程，而面向对象则是修改其行为，似的该对象的行为能适配流程。具有很强的灵活性和可维护性

#### 面向对象的三大特征

- 封装  
隐藏一切可隐藏的细节，只暴露最简单的行为。也就是说**通信方不需要知道被通信方的实现，只需要知道如何通信即可，也就是被通信方的实现对通信方而言是透明对**
在java中，我们一般只会暴露类的api，而不会告知是如何实现的，对于调用方而言，实现细节都是透明的。
- 继承  
继承指的是一种能力，**是由当前类派生出新类的过程**，可以在现有类的基础上构建新的类。
在java中：由继承创建的新类我们统称为子类/派生类；而被继承的类称为父类/基类。Object是所有的父类。还有一点java中，是单继承模式的。
- 多态  
是同一种行为具有不同表现活形态的能力，是对象的多种表现能力的体现。
多态基础是继承，允许子对象赋予父对象不同的能力。
形成多态的条件有：
  1. 继承基类
  2. 重写
  3. 父类引用指向子类对象
在java中与多态有关系的是重写：由子类重新定义父类的行为，也就是条件2。而重载却不是，重载是类内部多个相同行为，不同参数的一个多样化。和多态没有关系。

#### 面向对象的5大原则
S.O.L.I.D简称面向对象的5大原则，分别是：单一原则，开放封闭原则，里氏替换原则，接口隔离原则，依赖倒置原则。虽然大多数我们在编写程序的时候是不太会记得这些原则，这些原则也不应该使用在编写程序上，而是在设计程序上面。准确来说，这是一个基本的优化原则。
- 单一原则
> 指某一个类的功能，职责要单一，不能包罗万象。

也就是对于类要足够的细化，对行为足够的明确，隔离不必要的行为。
- 开放封闭原则
> 一个模块在扩展性方面应该是开放的，而在更改性上面应该是封闭的。

这个其实很好理解，比如我们在一个模块中需要新增一个功能（不是扩展性的），而这个新功能和其中一个功能有很大一部分相似，一般情况下，我们修改下原接口，多个特判形式的编写，其实就可以解决问题，但是这样子做不符合开放封闭原则。我们不应该在更改上面是开放的，改动之前的逻辑，而是应该新开一个接口，扩展功能，并把两部分相同的地方抽象出来。
- 里氏替换原则
>子类可以出现在父类能够出现的任何地方，并代替它
这句话就是父类能使用的地方，子类也都可以代替它。
- 依赖倒置原则
  > 实体必须依赖抽象而不是具体实现

这个就不太好理解了,换个方式说:
  1. 高层次的模块不应该依赖低层次的实现
  2. 高层次的模块应该依赖抽象
emmm更加不好理解了，最简单的来说，就是程序应该依赖抽象接口，而不是依赖具体的实现。拿很简单的例子而言，我们在代码中声明对象的时候，是否都是XXX x=new XXX(),其实这种就是依赖了具体的实现，因为后面指待的就是特定的XXX类，那么应该怎么样的？这边就要借助设计模式中的抽象工厂模式（注意是抽象哦，因为不依赖具体的实现），利用工厂模式来代替直接声明，这样子做有个很大好处，一旦某一天XXX类要被替换了，那安装之前的方式，我们是不是要该全部XXX类所在的地方？这样子很容易出现遗漏。而利用了抽象工厂模式，我们其实只要该该工厂模式内部的实现一个地方就好了，如果要替换工厂模式，也直接替换工厂模式的实现就好了（所以为嘛是抽象工厂模式了），这样程序就有很好的扩展性和灵活性。
- 接口隔离原则
> 拆分非常庞大臃肿的接口成为更小和更具体的接口

个人理解上呢，这个相当于是接口的单一原则，也就是接口的职责要足够细化，功能单一，这样子使用方就不需要依赖它实现不使用的方法了


### 总结
大致内容就这样子描述完了，这章基本描述了对象，面向对象思想里面的部分内容，讲了大概的概念，全是文字，好枯燥的呦。

[欢迎关注我的博客-FightCrap](https://fightcrap.github.io/)